// Code generated by oto; DO NOT EDIT.

// HeadersFunc allows you to mutate headers for each request.
// Useful for adding authorization into the client.
interface HeadersFunc {
	(headers: Headers): void;
}

// Client provides access to remote services.
export class Client {
	// basepath is the path prefix for the requests.
	// This may be a path, or an absolute URL.
	public basepath: String = 'https://nb.dev.kolomajr.com/complaints/'
	// public basepath: String = '/complaints/'
	// headers allows calling code to mutate the HTTP
	// headers of the underlying HTTP requests.
	public headers?: HeadersFunc
}


// ComplaintsService handle the conversational form requests
export class ComplaintsService {
	constructor(readonly client: Client) {}
	
		async analytics(analyticsRequest?: AnalyticsRequest, modifyHeaders?: HeadersFunc): Promise<AnalyticsResponse> {
		if (analyticsRequest == null) {
			analyticsRequest = new AnalyticsRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.Analytics', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(analyticsRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.Analytics: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new AnalyticsResponse(json);
		})
	}
	
		async assignComplaint(assignComplaintRequest?: AssignComplaintRequest, modifyHeaders?: HeadersFunc): Promise<AssignComplaintResponse> {
		if (assignComplaintRequest == null) {
			assignComplaintRequest = new AssignComplaintRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.AssignComplaint', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(assignComplaintRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.AssignComplaint: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new AssignComplaintResponse(json);
		})
	}
	
		async attachMedia(attachMediaRequest?: AttachMediaRequest, modifyHeaders?: HeadersFunc): Promise<AttachMediaResponse> {
		if (attachMediaRequest == null) {
			attachMediaRequest = new AttachMediaRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.AttachMedia', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(attachMediaRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.AttachMedia: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new AttachMediaResponse(json);
		})
	}
	
		async closeComplaint(closeComplaintRequest?: CloseComplaintRequest, modifyHeaders?: HeadersFunc): Promise<CloseComplaintResponse> {
		if (closeComplaintRequest == null) {
			closeComplaintRequest = new CloseComplaintRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.CloseComplaint', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(closeComplaintRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.CloseComplaint: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new CloseComplaintResponse(json);
		})
	}
	
		async complaintHistory(complaintHistoryRequest?: ComplaintHistoryRequest, modifyHeaders?: HeadersFunc): Promise<ComplaintHistoryResponse> {
		if (complaintHistoryRequest == null) {
			complaintHistoryRequest = new ComplaintHistoryRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.ComplaintHistory', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(complaintHistoryRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.ComplaintHistory: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new ComplaintHistoryResponse(json);
		})
	}
	
		async listComplaints(listComplaintsRequest?: ListComplaintsRequest, modifyHeaders?: HeadersFunc): Promise<ListComplaintsResponse> {
		if (listComplaintsRequest == null) {
			listComplaintsRequest = new ListComplaintsRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.ListComplaints', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(listComplaintsRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.ListComplaints: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new ListComplaintsResponse(json);
		})
	}
	
		async submitComplaint(submitComplaintRequest?: SubmitComplaintRequest, modifyHeaders?: HeadersFunc): Promise<SubmitComplaintResponse> {
		if (submitComplaintRequest == null) {
			submitComplaintRequest = new SubmitComplaintRequest();
		}
		const headers: Headers = new Headers();
		headers.set('Accept', 'application/json');
		headers.set('Content-Type', 'application/json');
		if (this.client.headers) {
			await this.client.headers(headers);
		}
		if (modifyHeaders) {
			await modifyHeaders(headers)
		}
		const response = await fetch(this.client.basepath + 'ComplaintsService.SubmitComplaint', {
			method: 'POST',
			headers: headers,
			body: JSON.stringify(submitComplaintRequest),
		})
		if (response.status !== 200) {
			throw new Error(`ComplaintsService.SubmitComplaint: ${response.status} ${response.statusText}`);
		}
		return response.json().then((json) => {
			if (json.error) {
				throw new Error(json.error);
			}
			return new SubmitComplaintResponse(json);
		})
	}
	
}



// AnalyticsRequest is the request object for attaching media to complaints
export class AnalyticsRequest {
	constructor(data?: any) {
		if (data) {
		
		}
	}

}

// AnalyticsResponse is a response object
export class AnalyticsResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.total = data.total;
			
		
			
			this.pending = data.pending;
			
		
			
			this.closed = data.closed;
			
		
			
			this.resolved = data.resolved;
			
		
			
			this.in_progress = data.in_progress;
			
		
			
				
					if (data.daily_submissions) {
						this.daily_submissions = []
						for (let i = 0; i < data.daily_submissions.length; i++) {
							this.daily_submissions.push(new DailySubmissionEntry(data.daily_submissions[i]));
						}
					}
				
			
		
			
			this.error = data.error;
			
		
		}
	}

		total: number = numberDefault;

		pending: number = numberDefault;

		closed: number = numberDefault;

		resolved: number = numberDefault;

		in_progress: number = numberDefault;

		daily_submissions?: DailySubmissionEntry[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// AssignComplaintRequest is the request object for assigning a complaint
export class AssignComplaintRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.user_id = data.user_id;
			
		
		}
	}

		id: string = UUIDDefault;

		user_id: number = numberDefault;

}

// AssignComplaintResponse is a response object
export class AssignComplaintResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.error = data.error;
			
		
		}
	}

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// AttachMediaRequest is the request object for attaching media to complaints
export class AttachMediaRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.media_id = data.media_id;
			
		
		}
	}

		id: string = UUIDDefault;

		media_id: string = UUIDDefault;

}

// AttachMediaResponse is a response object
export class AttachMediaResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.url = data.url;
			
		
			
			this.error = data.error;
			
		
		}
	}

		url: string = stringDefault;

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// CloseComplaintRequest is the request object for submitting new complaints
export class CloseComplaintRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.resolved = data.resolved;
			
		
		}
	}

		id: string = UUIDDefault;

		resolved: boolean = booleanDefault;

}

// CloseComplaintResponse is a response object containing submission responses
export class CloseComplaintResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.closed = data.closed;
			
		
			
			this.error = data.error;
			
		
		}
	}

		closed: boolean = booleanDefault;

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

export class Complaint {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.user_id = data.user_id;
			
		
			
			this.created_at = data.created_at;
			
		
			
			this.updated_at = data.updated_at;
			
		
			
			this.category = data.category;
			
		
			
			this.message = data.message;
			
		
			
			this.closed = data.closed;
			
		
			
			this.closed_at = data.closed_at;
			
		
			
			this.resolved = data.resolved;
			
		
			
			this.assignee_id = data.assignee_id;
			
		
			
			this.assigned_at = data.assigned_at;
			
		
			
			this.media_urls = data.media_urls;
			
		
		}
	}

		id: string = UUIDDefault;

		user_id: number = numberDefault;

		created_at: string = stringDefault;

		updated_at: string = stringDefault;

		category: string = stringDefault;

		message: string = stringDefault;

		closed: boolean = booleanDefault;

		closed_at: string = stringDefault;

		resolved: boolean = booleanDefault;

		assignee_id: number = numberDefault;

		assigned_at: string = stringDefault;

		media_urls?: string[];

}

// ComplaintHistoryRequest is the request object for submitting new complaints
export class ComplaintHistoryRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
		}
	}

		id: string = UUIDDefault;

}

// ComplaintHistoryResponse is a response object containing submission responses
export class ComplaintHistoryResponse {
	constructor(data?: any) {
		if (data) {
		
			
				
					if (data.history) {
						this.history = []
						for (let i = 0; i < data.history.length; i++) {
							this.history.push(new HistoryEntry(data.history[i]));
						}
					}
				
			
		
			
			this.error = data.error;
			
		
		}
	}

		history?: HistoryEntry[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

export class DailySubmissionEntry {
	constructor(data?: any) {
		if (data) {
		
			
			this.date = data.date;
			
		
			
			this.count = data.count;
			
		
		}
	}

		date: string = stringDefault;

		count: number = numberDefault;

}

export class HistoryEntry {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.created_at = data.created_at;
			
		
			
			this.message = data.message;
			
		
		}
	}

		id: string = UUIDDefault;

		created_at: string = stringDefault;

		message: string = stringDefault;

}

// ListComplaintsRequest is the request object for submitting new complaints
export class ListComplaintsRequest {
	constructor(data?: any) {
		if (data) {
		
		}
	}

}

// ListComplaintsResponse is a response object containing submission responses
export class ListComplaintsResponse {
	constructor(data?: any) {
		if (data) {
		
			
				
					if (data.complaints) {
						this.complaints = []
						for (let i = 0; i < data.complaints.length; i++) {
							this.complaints.push(new Complaint(data.complaints[i]));
						}
					}
				
			
		
			
			this.error = data.error;
			
		
		}
	}

		complaints?: Complaint[];

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// SubmitComplaintRequest is the request object for submitting new complaints
export class SubmitComplaintRequest {
	constructor(data?: any) {
		if (data) {
		
			
			this.category = data.category;
			
		
			
			this.message = data.message;
			
		
		}
	}

		category: string = stringDefault;

		message: string = stringDefault;
}

// SubmitComplaintResponse is a response object containing submission responses
export class SubmitComplaintResponse {
	constructor(data?: any) {
		if (data) {
		
			
			this.id = data.id;
			
		
			
			this.error = data.error;
			
		
		}
	}

		id: string = UUIDDefault;

	// Error is string explaining what went wrong. Empty if everything was fine.
	error: string = stringDefault;

}

// these defaults make the template easier to write.
const stringDefault = ''
const numberDefault = 0
const booleanDefault = false 
const anyDefault = null
const UUIDDefault = "00000000-0000-0000-0000-000000000000";
